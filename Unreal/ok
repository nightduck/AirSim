Binary file ./Environments/Blocks/.vs/Blocks/v15/Browse.VC.db matches
Binary file ./Environments/Blocks/.vs/Blocks/v15/ipch/AutoPCH/3efd89538fd997d7/WORLDSIMAPI.ipch matches
./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
Binary file ./Environments/Blocks/Plugins/AirSim/Intermediate/Build/Win64/UE4Editor/Development/AirSim/Module.AirSim.cpp.obj matches
./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/WorldSimApi.h:	virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:C:\Airsim_forked_cloned_properly\Unreal\Environments\Blocks\Plugins\AirSim\Source\SimMode/SimModeBase.h(138): error C2039: 'WorldSimApiBase': is not a member of 'msr::airlib'
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\api\WorldSimApiBase.hpp(66): error C2433: 'msr::airlib::WorldSimApiBase::ASimModeBase': 'virtual' not permitted on data declarations
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(84): warning C4265: 'msr::airlib::powerlib::CurveEvaluator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Intermediate/Build/Unused/Blocks.log:c:\airsim_forked_cloned_properly\unreal\environments\blocks\plugins\airsim\source\airlib\include\physics\Battery.hpp(173): warning C4265: 'msr::airlib::powerlib::PowerEstimator': class has virtual functions, but destructor is not virtual
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./ok:./Environments/Blocks/Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./Plugins/AirSim/Source/AirBlueprintLib.cpp:msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType UAirBlueprintLib::mesh_naming_method_ =
./Plugins/AirSim/Source/AirBlueprintLib.cpp:    msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName;
./Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./Plugins/AirSim/Source/AirBlueprintLib.cpp:    case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::OwnerName:
./Plugins/AirSim/Source/AirBlueprintLib.h:        case msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType::StaticMeshName:
./Plugins/AirSim/Source/AirBlueprintLib.h:    static void SetMeshNamingMethod(msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType method)
./Plugins/AirSim/Source/AirBlueprintLib.h:    static msr::airlib::AirSimSettings::SegmentationSetting::MeshNamingMethodType mesh_naming_method_;
./Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setHeadRotation(const msr::airlib::Quaternionr& q)
./Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Quaternionr AAirSimCharacter::getHeadRotation() const
./Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Quaternionr::Identity();
./Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose)
./Plugins/AirSim/Source/AirSimCharacter.cpp:void AAirSimCharacter::setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses)
./Plugins/AirSim/Source/AirSimCharacter.cpp:msr::airlib::Pose AAirSimCharacter::getBonePose(const std::string& bone_name) const
./Plugins/AirSim/Source/AirSimCharacter.cpp:    return msr::airlib::Pose::nanPose();
./Plugins/AirSim/Source/AirSimCharacter.cpp:std::unordered_map<std::string, msr::airlib::Pose> AAirSimCharacter::getBonePoses(const std::vector<std::string>& bone_names) const
./Plugins/AirSim/Source/AirSimCharacter.cpp:    return std::unordered_map<std::string, msr::airlib::Pose>();
./Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setHeadRotation(const msr::airlib::Quaternionr& q);
./Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Quaternionr getHeadRotation() const;
./Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePose(const std::string& bone_name, const msr::airlib::Pose& pose);
./Plugins/AirSim/Source/AirSimCharacter.h:    virtual void setBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses);
./Plugins/AirSim/Source/AirSimCharacter.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> getBonePoses(const std::vector<std::string>& bone_names) const;
./Plugins/AirSim/Source/AirSimCharacter.h:    virtual msr::airlib::Pose getBonePose(const std::string& bone_name) const;
./Plugins/AirSim/Source/AirSimGameMode.cpp:class AUnrealLog : public msr::airlib::Utils::Logger
./Plugins/AirSim/Source/AirSimGameMode.cpp:        if (level == msr::airlib::Utils::kLogLevelError) {
./Plugins/AirSim/Source/AirSimGameMode.cpp:        else if (level == msr::airlib::Utils::kLogLevelWarn) {
./Plugins/AirSim/Source/AirSimGameMode.cpp:        msr::airlib::Utils::Logger::log(level, message);
./Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Vector3r Vector3r;
./Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Quaternionr Quaternionr;
./Plugins/AirSim/Source/NedTransform.h:    typedef msr::airlib::Pose Pose;
./Plugins/AirSim/Source/PawnSimApi.cpp:    home_geo_point_ = msr::airlib::EarthUtils::nedToGeodetic(nedWrtOrigin, 
./Plugins/AirSim/Source/PawnSimApi.cpp:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Plugins/AirSim/Source/PawnSimApi.cpp:    state_.collision_info.time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::RCData PawnSimApi::getRCData() const
./Plugins/AirSim/Source/PawnSimApi.cpp:    rc_data_ = msr::airlib::RCData();
./Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::reportState(msr::airlib::StateReporter& reporter)
./Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::VehicleSimApiBase::reportState(reporter);
./Plugins/AirSim/Source/PawnSimApi.cpp:    using namespace msr::airlib;
./Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::CameraInfo PawnSimApi::getCameraInfo(const std::string& camera_name) const
./Plugins/AirSim/Source/PawnSimApi.cpp:    msr::airlib::CameraInfo camera_info;
./Plugins/AirSim/Source/PawnSimApi.cpp:void PawnSimApi::setCameraOrientation(const std::string& camera_name, const msr::airlib::Quaternionr& orientation)
./Plugins/AirSim/Source/PawnSimApi.cpp:    next_kinematics.twist.angular = msr::airlib::VectorMath::toAngularVelocity(
./Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Kinematics::State* PawnSimApi::getGroundTruthKinematics() const
./Plugins/AirSim/Source/PawnSimApi.cpp:const msr::airlib::Environment* PawnSimApi::getGroundTruthEnvironment() const
./Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Kinematics* PawnSimApi::getKinematics()
./Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::Environment* PawnSimApi::getEnvironment()
./Plugins/AirSim/Source/PawnSimApi.cpp:    uint64_t timestamp_millis = static_cast<uint64_t>(msr::airlib::ClockFactory::get()->nowNanos() / 1.0E6);
./Plugins/AirSim/Source/PawnSimApi.cpp:msr::airlib::VehicleApiBase* PawnSimApi::getVehicleApiBase() const
./Plugins/AirSim/Source/PawnSimApi.h:class PawnSimApi : public msr::airlib::VehicleSimApiBase {
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::GeoPoint GeoPoint;
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Vector3r Vector3r;
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Pose Pose;
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Quaternionr Quaternionr;
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::CollisionInfo CollisionInfo;
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::VectorMath VectorMath;
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::real_T real_T;
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Utils Utils;
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings::VehicleSetting VehicleSetting;
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./Plugins/AirSim/Source/PawnSimApi.h:        msr::airlib::GeoPoint home_geopoint;
./Plugins/AirSim/Source/PawnSimApi.h:            UParticleSystem* collision_display_template_val, const msr::airlib::GeoPoint home_geopoint_val,
./Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::CameraInfo getCameraInfo(const std::string& camera_name) const override;
./Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::RCData getRCData() const override;
./Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Kinematics::State* getGroundTruthKinematics() const override;
./Plugins/AirSim/Source/PawnSimApi.h:    virtual const msr::airlib::Environment* getGroundTruthEnvironment() const override;
./Plugins/AirSim/Source/PawnSimApi.h:    virtual void reportState(msr::airlib::StateReporter& reporter) override;
./Plugins/AirSim/Source/PawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const;
./Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Kinematics* getKinematics();
./Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::Environment* getEnvironment();
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Kinematics Kinematics;
./Plugins/AirSim/Source/PawnSimApi.h:    typedef msr::airlib::Environment Environment;
./Plugins/AirSim/Source/PawnSimApi.h:    msr::airlib::GeoPoint home_geo_point_;
./Plugins/AirSim/Source/PawnSimApi.h:    mutable msr::airlib::RCData rc_data_;
./Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Kinematics> kinematics_;
./Plugins/AirSim/Source/PawnSimApi.h:    std::unique_ptr<msr::airlib::Environment> environment_;
./Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::ProjectionMatrix APIPCamera::getProjectionMatrix(const APIPCamera::ImageType image_type) const
./Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./Plugins/AirSim/Source/PIPCamera.cpp:        msr::airlib::ProjectionMatrix mat;
./Plugins/AirSim/Source/PIPCamera.cpp:msr::airlib::Pose APIPCamera::getPose() const
./Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./Plugins/AirSim/Source/PIPCamera.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::ProjectionMatrix getProjectionMatrix(const APIPCamera::ImageType image_type) const;
./Plugins/AirSim/Source/PIPCamera.h:    msr::airlib::Pose getPose() const;
./Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./Plugins/AirSim/Source/Recording/RecordingFile.cpp:void RecordingFile::startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./Plugins/AirSim/Source/Recording/RecordingFile.h:    void appendRecord(const std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./Plugins/AirSim/Source/Recording/RecordingFile.h:    void startRecording(msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./Plugins/AirSim/Source/Recording/RecordingThread.cpp:void FRecordingThread::startRecording(const msr::airlib::ImageCaptureBase* image_capture, const msr::airlib::Kinematics::State* kinematics, 
./Plugins/AirSim/Source/Recording/RecordingThread.cpp:    const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api)
./Plugins/AirSim/Source/Recording/RecordingThread.cpp:    instance_->last_pose_ = msr::airlib::Pose();
./Plugins/AirSim/Source/Recording/RecordingThread.cpp:            bool interval_elapsed = msr::airlib::ClockFactory::get()->elapsedSince(last_screenshot_on_) > settings_.record_interval;
./Plugins/AirSim/Source/Recording/RecordingThread.cpp:                last_screenshot_on_ = msr::airlib::ClockFactory::get()->nowNanos();
./Plugins/AirSim/Source/Recording/RecordingThread.cpp:                std::vector<msr::airlib::ImageCaptureBase::ImageResponse> responses;
./Plugins/AirSim/Source/Recording/RecordingThread.h:    typedef msr::airlib::AirSimSettings::RecordingSetting RecordingSetting;
./Plugins/AirSim/Source/Recording/RecordingThread.h:    static void startRecording(const msr::airlib::ImageCaptureBase* camera, const msr::airlib::Kinematics::State* kinematics, 
./Plugins/AirSim/Source/Recording/RecordingThread.h:        const RecordingSetting& settings, msr::airlib::VehicleSimApiBase* vehicle_sim_api);
./Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::ImageCaptureBase* image_capture_;
./Plugins/AirSim/Source/Recording/RecordingThread.h:    const msr::airlib::Kinematics::State* kinematics_;
./Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::VehicleSimApiBase* vehicle_sim_api_;
./Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::TTimePoint last_screenshot_on_;
./Plugins/AirSim/Source/Recording/RecordingThread.h:    msr::airlib::Pose last_pose_;
./Plugins/AirSim/Source/RenderRequest.cpp:    wait_signal_(new msr::airlib::WorkerThreadSignal),
./Plugins/AirSim/Source/RenderRequest.cpp:            results_[i]->time_stamp = msr::airlib::ClockFactory::get()->nowNanos();
./Plugins/AirSim/Source/RenderRequest.h:        msr::airlib::TTimePoint time_stamp;
./Plugins/AirSim/Source/RenderRequest.h:    std::shared_ptr<msr::airlib::WorkerThreadSignal> wait_signal_;
./Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::getExecutableFullPath("settings.json").c_str()), settingsText)
./Plugins/AirSim/Source/SimHUD/SimHUD.cpp:        readSettingsTextFromFile(FString(msr::airlib::Settings::Settings::getUserDirectoryFullPath("settings.json").c_str()), settingsText));
./Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./Plugins/AirSim/Source/SimHUD/SimHUD.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:    api_provider_.reset(new msr::airlib::ApiProvider(world_sim_api_.get()));
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeBase::createApiServer() const
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            static_cast<msr::airlib::TTimeDelta>(msr::airlib::SteppableClock::DefaultStepSize * clock_speed)));
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            auto coord = msr::airlib::EarthCelestial::getSunCoordinates(cur_time, settings.origin_geopoint.home_geo_point.latitude,
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:const msr::airlib::AirSimSettings& ASimModeBase::getSettings() const
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:void ASimModeBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::StateReporter& reporter = *debug_reporter.getReporter();
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const msr::airlib::Kinematics::State* kinematics = vehicle_sim_api->getGroundTruthKinematics();
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:FRotator ASimModeBase::toFRotator(const msr::airlib::AirSimSettings::Rotation& rotation, const FRotator& default_val)
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                msr::airlib::Vector3r settings_position = vehicle_setting.position;
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                if (!msr::airlib::VectorMath::hasNan(settings_position))
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            const auto& home_geopoint= msr::airlib::EarthUtils::nedToGeodetic(pawn_ned_pos, getSettings().origin_geopoint);
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:msr::airlib::VehicleApiBase* ASimModeBase::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:        msr::airlib::VehicleApiBase* api = getApiProvider()->getVehicleApi(vehicle_name);
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            msr::airlib::uint count_lidars = api->getSensors().size(msr::airlib::SensorBase::SensorType::Lidar);
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:            for (msr::airlib::uint i = 0; i < count_lidars; i++) {
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                const msr::airlib::LidarSimple* lidar =
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    static_cast<const msr::airlib::LidarSimple*>(api->getSensors().getByType(msr::airlib::SensorBase::SensorType::Lidar, i));
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                    msr::airlib::LidarData lidar_data = lidar->getOutput();
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                        msr::airlib::Vector3r point(lidar_data.point_cloud[j], lidar_data.point_cloud[j + 1], lidar_data.point_cloud[j + 2]);
./Plugins/AirSim/Source/SimMode/SimModeBase.cpp:                            msr::airlib::Vector3r point_w = msr::airlib::VectorMath::transformToWorldFrame(point, lidar_data.pose, true);
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::ApiProvider* getApiProvider() const
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const;
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter);
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    virtual const msr::airlib::AirSimSettings& getSettings() const;
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimePoint TTimePoint;
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::WorldSimApiBase> world_sim_api_;
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiProvider> api_provider_;
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::unique_ptr<msr::airlib::ApiServerBase> api_server_;
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    msr::airlib::StateReporterWrapper debug_reporter_;
./Plugins/AirSim/Source/SimMode/SimModeBase.h:    std::vector<std::unique_ptr<msr::airlib::VehicleSimApiBase>> vehicle_sim_apis_;
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    std::vector<msr::airlib::UpdatableObject*> vehicles;
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:    physics_world_.reset(new msr::airlib::PhysicsWorld(std::move(physics_engine),
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        msr::airlib::Settings fast_phys_settings;
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:        if (msr::airlib::Settings::singleton().getChild("FastPhysicsEngine", fast_phys_settings)) {
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine(fast_phys_settings.getBool("EnableGroundLock", true)));
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:            physics_engine.reset(new msr::airlib::FastPhysicsEngine());
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.cpp:void ASimModeWorldBase::updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter)
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    virtual void updateDebugReport(msr::airlib::StateReporterWrapper& debug_reporter) override;
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::PhysicsEngineBase PhysicsEngineBase;
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    typedef msr::airlib::ClockFactory ClockFactory;
./Plugins/AirSim/Source/SimMode/SimModeWorldBase.h:    std::unique_ptr<msr::airlib::PhysicsWorld> physics_world_;
./Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getImages(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses) const
./Plugins/AirSim/Source/UnrealImageCapture.cpp:void UnrealImageCapture::getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./Plugins/AirSim/Source/UnrealImageCapture.cpp:    std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const
./Plugins/AirSim/Source/UnrealImageCapture.cpp:            msr::airlib::Pose pose = camera->getPose();
./Plugins/AirSim/Source/UnrealImageCapture.cpp:bool UnrealImageCapture::updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request)
./Plugins/AirSim/Source/UnrealImageCapture.h:class UnrealImageCapture : public msr::airlib::ImageCaptureBase
./Plugins/AirSim/Source/UnrealImageCapture.h:    typedef msr::airlib::ImageCaptureBase::ImageType ImageType;
./Plugins/AirSim/Source/UnrealImageCapture.h:    void getSceneCaptureImage(const std::vector<msr::airlib::ImageCaptureBase::ImageRequest>& requests, 
./Plugins/AirSim/Source/UnrealImageCapture.h:        std::vector<msr::airlib::ImageCaptureBase::ImageResponse>& responses, bool use_safe_method) const;
./Plugins/AirSim/Source/UnrealImageCapture.h:    bool updateCameraVisibility(APIPCamera* camera, const msr::airlib::ImageCaptureBase::ImageRequest& request);
./Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.cpp:msr::airlib::real_T UnrealDistanceSensor::getRayLength(const msr::airlib::Pose& pose)
./Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:class UnrealDistanceSensor : public msr::airlib::DistanceSimple {
./Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    virtual msr::airlib::real_T getRayLength(const msr::airlib::Pose& pose) override;
./Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using Vector3r = msr::airlib::Vector3r;
./Plugins/AirSim/Source/UnrealSensors/UnrealDistanceSensor.h:    using VectorMath = msr::airlib::VectorMath;
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:void UnrealLidarSensor::getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud)
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::LidarSimpleParams params = getParams();
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:bool UnrealLidarSensor::shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    const msr::airlib::LidarSimpleParams params, Vector3r &point)
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_l = msr::airlib::VectorMath::toQuaternion(
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(vertical_angle),   //pitch - rotation around Y axis
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:        msr::airlib::Utils::degreesToRadians(horizontal_angle));//yaw   - rotation around Z axis
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_b = VectorMath::coordOrientationAdd(ray_q_l, lidar_pose.orientation);
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.cpp:    msr::airlib::Quaternionr ray_q_w = VectorMath::coordOrientationAdd(ray_q_b, vehicle_pose.orientation);
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:class UnrealLidarSensor : public msr::airlib::LidarSimple {
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    virtual void getPointCloud(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        msr::airlib::TTimeDelta delta_time, msr::airlib::vector<msr::airlib::real_T>& point_cloud) override;
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using Vector3r = msr::airlib::Vector3r;
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    using VectorMath = msr::airlib::VectorMath;
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    bool shootLaser(const msr::airlib::Pose& lidar_pose, const msr::airlib::Pose& vehicle_pose,
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:        const msr::airlib::LidarSimpleParams params, Vector3r &point);
./Plugins/AirSim/Source/UnrealSensors/UnrealLidarSensor.h:    msr::airlib::vector<msr::airlib::real_T> laser_angles_;
./Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:std::unique_ptr<msr::airlib::SensorBase> UnrealSensorFactory::createSensorFromSettings(
./Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:    using SensorBase = msr::airlib::SensorBase;
./Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.cpp:        return msr::airlib::SensorFactory::createSensorFromSettings(sensor_setting);
./Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:class UnrealSensorFactory : public msr::airlib::SensorFactory {
./Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Plugins/AirSim/Source/UnrealSensors/UnrealSensorFactory.h:    virtual std::unique_ptr<msr::airlib::SensorBase> createSensorFromSettings(
./Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    const msr::airlib::CarApiBase::CarControls& getKeyBoardControls() const
./Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    typedef msr::airlib::AirSimSettings AirSimSettings;
./Plugins/AirSim/Source/Vehicles/Car/CarPawn.h:    msr::airlib::CarApiBase::CarControls keyboard_controls_;
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:CarPawnApi::CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory, 
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment)
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    : msr::airlib::CarApiBase(vehicle_setting, sensor_factory, state, environment),
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:const msr::airlib::CarApiBase::CarControls& CarPawnApi::getCarControls() const
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::CarApiBase::CarState CarPawnApi::getCarState() const
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:        msr::airlib::ClockFactory::get()->nowNanos()
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::reset();
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:    msr::airlib::CarApiBase::update();
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.cpp:msr::airlib::GeoPoint CarPawnApi::getHomeGeoPoint() const
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:class CarPawnApi : public msr::airlib::CarApiBase {
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    typedef msr::airlib::ImageCaptureBase ImageCaptureBase;
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    CarPawnApi(ACarPawn* pawn, const msr::airlib::Kinematics::State* pawn_kinematics, const msr::airlib::GeoPoint& home_geopoint,
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::AirSimSettings::VehicleSetting* vehicle_setting, std::shared_ptr<msr::airlib::SensorFactory> sensor_factory,
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:        const msr::airlib::Kinematics::State& state, const msr::airlib::Environment& environment);
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    virtual msr::airlib::GeoPoint getHomeGeoPoint() const override;
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    const msr::airlib::Kinematics::State* pawn_kinematics_;
./Plugins/AirSim/Source/Vehicles/Car/CarPawnApi.h:    msr::airlib::GeoPoint  home_geopoint_;
./Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:using namespace msr::airlib;
./Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:void CarPawnSimApi::createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint)
./Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.cpp:    const msr::airlib::Kinematics::State* kinematics = getGroundTruthKinematics();
./Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    msr::airlib::CarApiBase* getVehicleApi() const
./Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    void createVehicleApi(ACarPawn* pawn, const msr::airlib::GeoPoint& home_geopoint);
./Plugins/AirSim/Source/Vehicles/Car/CarPawnSimApi.h:    std::unique_ptr<msr::airlib::CarApiBase> vehicle_api_;
./Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeCar::createApiServer() const
./Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::CarRpcLibServer(
./Plugins/AirSim/Source/Vehicles/Car/SimModeCar.cpp:msr::airlib::VehicleApiBase* ASimModeCar::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::ClockFactory ClockFactory;
./Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimePoint TTimePoint;
./Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::TTimeDelta TTimeDelta;
./Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VehicleSimApiBase VehicleSimApiBase;
./Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::VectorMath VectorMath;
./Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    typedef msr::airlib::Vector3r Vector3r;
./Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./Plugins/AirSim/Source/Vehicles/Car/SimModeCar.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeComputerVision::createApiServer() const
./Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::RpcLibServerBase(
./Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:    return vehicle_type == msr::airlib::AirSimSettings::kVehicleTypeComputerVision;
./Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.cpp:msr::airlib::VehicleApiBase* ASimModeComputerVision::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./Plugins/AirSim/Source/Vehicles/ComputerVision/SimModeComputerVision.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnEvents.h:    typedef msr::airlib::real_T real_T;
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.cpp:using namespace msr::airlib;
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::real_T real_T;
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Utils Utils;
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::MultiRotor MultiRotor;
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::StateReporter StateReporter;
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::UpdatableObject UpdatableObject;
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    typedef msr::airlib::Pose Pose;
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    msr::airlib::MultirotorApiBase* getVehicleApi() const
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    virtual msr::airlib::VehicleApiBase* getVehicleApiBase() const override
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultirotorApiBase> vehicle_api_;
./Plugins/AirSim/Source/Vehicles/Multirotor/MultirotorPawnSimApi.h:    std::unique_ptr<msr::airlib::MultiRotorParams> vehicle_params_;
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    typedef msr::airlib::ClockFactory ClockFactory;
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        ClockFactory::get(std::make_shared<msr::airlib::ScalableClock>(clock_speed == 1 ? 1 : 1 / clock_speed));
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:        //static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9))); //no clock_speed multiplier
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:            ClockFactory::get(std::make_shared<msr::airlib::SteppableClock>(
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:                static_cast<msr::airlib::TTimeDelta>(getPhysicsLoopPeriod() * 1E-9 * clock_speed)));
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:std::unique_ptr<msr::airlib::ApiServerBase> ASimModeWorldMultiRotor::createApiServer() const
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:    return std::unique_ptr<msr::airlib::ApiServerBase>(new msr::airlib::MultirotorRpcLibServer(
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.cpp:msr::airlib::VehicleApiBase* ASimModeWorldMultiRotor::getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual std::unique_ptr<msr::airlib::ApiServerBase> createApiServer() const override;
./Plugins/AirSim/Source/Vehicles/Multirotor/SimModeWorldMultiRotor.h:    virtual msr::airlib::VehicleApiBase* getVehicleApi(const PawnSimApi::Params& pawn_sim_api_params,
./Plugins/AirSim/Source/WorldSimApi.cpp:    unsigned char param_n = static_cast<unsigned char>(msr::airlib::Utils::toNumeric<WeatherParameter>(param));
./Plugins/AirSim/Source/WorldSimApi.cpp:    EWeatherParamScalar param_e = msr::airlib::Utils::toEnum<EWeatherParamScalar>(param_n);
./Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name)
./Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Quaternionr WorldSimApi::charGetHeadRotation(const std::string& character_name) const
./Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name)
./Plugins/AirSim/Source/WorldSimApi.cpp:msr::airlib::Pose WorldSimApi::charGetBonePose(const std::string& bone_name, const std::string& character_name) const
./Plugins/AirSim/Source/WorldSimApi.cpp:void WorldSimApi::charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name)
./Plugins/AirSim/Source/WorldSimApi.cpp:std::unordered_map<std::string, msr::airlib::Pose> WorldSimApi::charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const
./Plugins/AirSim/Source/WorldSimApi.h:class WorldSimApi : public msr::airlib::WorldSimApiBase {
./Plugins/AirSim/Source/WorldSimApi.h:    typedef msr::airlib::Pose Pose;
./Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetHeadRotation(const msr::airlib::Quaternionr& q, const std::string& character_name) override;
./Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Quaternionr charGetHeadRotation(const std::string& character_name) const override;
./Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePose(const std::string& bone_name, const msr::airlib::Pose& pose, const std::string& character_name) override;
./Plugins/AirSim/Source/WorldSimApi.h:    virtual msr::airlib::Pose charGetBonePose(const std::string& bone_name, const std::string& character_name) const override;
./Plugins/AirSim/Source/WorldSimApi.h:    virtual void charSetBonePoses(const std::unordered_map<std::string, msr::airlib::Pose>& poses, const std::string& character_name) override;
./Plugins/AirSim/Source/WorldSimApi.h:    virtual std::unordered_map<std::string, msr::airlib::Pose> charGetBonePoses(const std::vector<std::string>& bone_names, const std::string& character_name) const override;
